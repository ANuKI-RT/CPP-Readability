import argparse
import os
from pathlib import Path
from typing import List

from cli_cmd import Command
from code_processing.parser import ClangParser


def register_command(subparsers):
    parser = subparsers.add_parser(
        str(Command.CRAWL),
        description='Extract C++ code snippets in a given directory',
    )
    parser.add_argument("-i", "--input", type=Path, required=True,
                        help='Path to a directory contains C++ code snippets')
    parser.add_argument("-o", "--output", type=Path, required=True,
                        help='Path to directory to save extracted snippets.')
    parser.add_argument("-gf", "--genFileKeyword", type=str, default='SampleKeyword',
                        help='If the cpp file contains this keyword it is (partly auto-generated)')
    parser.add_argument("-gm", "--genMethodKeyword", type=str, default='SampleKeyword2',
                        help='If the method does NOT contain this keyword AND '
                             'is part of a (partly) auto-generated cpp-file, the method is auto-generated --> skip it')


def find_cpp_files(folder_path: Path) -> List[Path]:
    cpp_files = []
    for root, dirs, files in os.walk(folder_path):
        for file in files:
            if file.endswith('.cpp'):
                cpp_files.append(Path(os.path.join(root, file)))

    return cpp_files


def sanitize_file(source_code: str) -> str:
    return (source_code.replace("\\", "/")
            .replace('\n#include "stdafx.h"', '\n//#include "stdafx.h"'))


def save_extracted_snippet(method: str, path: Path):
    with path.open('w') as f:
        f.write(method)


def run(args: argparse.Namespace):
    input_path = args.input.resolve().absolute()
    output_path = args.output.resolve().absolute()

    assert args.input.is_dir(), 'input path should be a directory contains C++ code snippets'
    output_path.mkdir(exist_ok=True, parents=True)

    gen_file_keyword = args.genFileKeyword
    gen_method_keyword = args.genMethodKeyword
    project_name = args.output.stem

    clang_args = ['-x', 'c++', f'-I{str(input_path)}']
    parser = ClangParser(clang_args)

    extracted_signatures = set()
    total_extracted = 0
    total_skipped_len = 0
    total_skipped_gen = 0
    total_duplicates = 0

    cpp_files = find_cpp_files(input_path)
    for cpp_file in cpp_files:
        skipped_len = 0
        skipped_gen = 0
        skipped_duplicates = 0
        print(cpp_file)
        with open(cpp_file, 'r') as f:
            source_code = f.read()

        source_code = sanitize_file(source_code)
        generated_file = gen_file_keyword in source_code

        parser.parsing(source_code)
        methods = parser.extract_methods()

        count = 1
        for method in methods:
            method_lines = method.content.splitlines(keepends=False)
            signature = method_lines[0]
            if signature in extracted_signatures:
                skipped_duplicates += 1
                continue
            else:
                extracted_signatures.add(signature)

            if generated_file and (gen_method_keyword not in method.content):
                skipped_gen += 1
            elif len(method_lines) < 10 or len(method_lines) > 50:
                skipped_len += 1
            else:
                relpath = cpp_file.relative_to(input_path)
                output_filename = (str(relpath.with_suffix('.txt'))
                                   .replace('./', '')
                                   .replace('/', '_')
                                   .replace('.txt', f'_{count}.txt'))
                output_filename = f'{project_name}_{output_filename}'
                output_file_path = output_path / output_filename
                save_extracted_snippet(method.content, output_file_path)
                count += 1

        print(f'Extracted {str(count - 1)} methods. '
              f'Generated File: {str(generated_file)}. '
              f'Skipped {str(skipped_duplicates)} duplicates + '
              f'{str(skipped_gen)} autogenerated methods + '
              f'{str(skipped_len)} methods outside LOC range')

        if ((count - 1) + skipped_duplicates + skipped_gen + skipped_len) == 0:
            print('##### SUSPICIOUS: no method found at all ?! ####')

        total_extracted += count - 1
        total_skipped_len += skipped_len
        total_skipped_gen += skipped_gen
        total_duplicates += skipped_duplicates

    print(f'SUMMARY: Extracted {total_extracted} methods from '
          f'{len(cpp_files)} files. '
          f'Skipped {total_duplicates} duplicates + '
          f'{total_skipped_gen} autogenerated methods + '
          f'{total_skipped_len} methods outside LOC range')
